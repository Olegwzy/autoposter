#!/usr/bin/env python3
import os
import time
import threading
import schedule
import subprocess
import requests
import openai
from datetime import datetime
import pytz
import socket
from dotenv import load_dotenv
import telegram
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, ParseMode
from telegram.ext import Updater, CommandHandler, CallbackQueryHandler, MessageHandler, Filters

# === –ó–∞–≥—Ä—É–∑–∫–∞ .env ===
load_dotenv()
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_TOKEN_POSTER")
CHAT_ID = os.getenv("CHAT_ID", "1359259211")  # –º–æ–∂–Ω–æ –≤—ã–Ω–µ—Å—Ç–∏ –≤ .env –ø—Ä–∏ –∂–µ–ª–∞–Ω–∏–∏

openai.api_key = OPENAI_API_KEY

# === –ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å –£–∫—Ä–∞–∏–Ω—ã ===
TZ = pytz.timezone("Europe/Kiev")

# === –†–∞–±–æ—á–µ–µ –≤—Ä–µ–º—è ===
START_HOUR = 1
END_HOUR = 23

# === –ê–≤—Ç–æ–ø–æ—Å—Ç–µ—Ä –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ ===
autoposting_enabled = True
require_confirmation = True
current_topic = "–º–æ—Ç–∏–≤–∞—Ü–∏—è"
pending_posts = {}
post_interval = 60  # –º–∏–Ω—É—Ç

TOPICS = {
    "–º–æ—Ç–∏–≤–∞—Ü–∏—è": "–ù–∞–ø–∏—à–∏ –≤–¥–æ—Ö–Ω–æ–≤–ª—è—é—â–∏–π –ø–æ—Å—Ç –¥–ª—è Telegram.",
    "—Ñ–∏–Ω–∞–Ω—Å—ã": "–°–æ–∑–¥–∞–π –∫–æ—Ä–æ—Ç–∫–∏–π –ø–æ—Å—Ç —Å —Å–æ–≤–µ—Ç–æ–º –ø–æ –ª–∏—á–Ω—ã–º —Ñ–∏–Ω–∞–Ω—Å–∞–º.",
    "–Ω–æ–≤–æ—Å—Ç–∏": "–°–æ–∑–¥–∞–π –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω—ã–π –ø–æ—Å—Ç —Å –ø–æ—Å–ª–µ–¥–Ω–∏–º–∏ –º–∏—Ä–æ–≤—ã–º–∏ –Ω–æ–≤–æ—Å—Ç—è–º–∏.",
    "—É–∫—Ä–∞–∏–Ω–∞": "–°–æ–∑–¥–∞–π –ø–æ—Å—Ç –æ –Ω–æ–≤–æ—Å—Ç—è—Ö –£–∫—Ä–∞–∏–Ω—ã.",
    "it": "–°–æ–∑–¥–∞–π –∫–æ—Ä–æ—Ç–∫–∏–π –ø–æ—Å—Ç –æ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—è—Ö –∏–ª–∏ –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω–æ–º –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç–µ."
}

LOG_DIR = "/home/Deltacom/autoposter"
VM_API = "http://127.0.0.1:5000/api/vm"
ALLOWED_SERVICES = {"autoposter.service", "vm_api.service", "thinclient.service"}

# === –£—Ç–∏–ª–∏—Ç—ã ===
def check_internet(host="8.8.8.8", port=53, timeout=3):
    try:
        socket.setdefaulttimeout(timeout)
        socket.socket(socket.AF_INET, socket.SOCK_STREAM).connect((host, port))
        return True
    except Exception:
        return False

def tail_file(path, lines=20):
    try:
        with open(path, "r", encoding="utf-8", errors="ignore") as f:
            data = f.readlines()[-lines:]
        text = "".join(data)
        # –û–≥—Ä–∞–Ω–∏—á–∏–º —Ä–∞–∑–º–µ—Ä –ø–æ–¥ Telegram (4096 —Å–∏–º–≤–æ–ª–æ–≤)
        return text[-3500:] if len(text) > 3500 else text
    except Exception as e:
        return f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å {path}: {e}"

def systemctl(cmd_list):
    try:
        out = subprocess.check_output(["systemctl"] + cmd_list, stderr=subprocess.STDOUT).decode("utf-8")
        return 0, out
    except subprocess.CalledProcessError as e:
        return e.returncode, e.output.decode("utf-8", errors="ignore")

# === GPT ===
def gpt_reply(prompt: str) -> str:
    try:
        resp = openai.ChatCompletion.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}]
        )
        return resp.choices[0].message["content"].strip()
    except Exception as e:
        return f"‚ö†Ô∏è –û—à–∏–±–∫–∞ GPT: {e}"

# === –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–æ—Å—Ç–∞ ===
def generate_message():
    prompt = TOPICS.get(current_topic, TOPICS["–º–æ—Ç–∏–≤–∞—Ü–∏—è"])
    try:
        resp = openai.ChatCompletion.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}]
        )
        return resp.choices[0].message["content"]
    except Exception as e:
        print(f"[–û—à–∏–±–∫–∞ GPT] {e}")
        return None

# === –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ —Å—É—Ç–æ–∫ ===
def within_active_hours():
    now = datetime.now(TZ)
    return START_HOUR <= now.hour < END_HOUR

# === –ê–≤—Ç–æ–ø–æ—Å—Ç–∏–Ω–≥ ===
def job():
    if not autoposting_enabled or not within_active_hours():
        return

    message = generate_message()
    if not message:
        return

    if not require_confirmation:
        bot.send_message(
            chat_id=CHAT_ID,
            text=f"üìù –ü–æ—Å—Ç –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ (—Ä–µ–∂–∏–º –±–µ–∑ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è):\n\n{message}",
            parse_mode=ParseMode.MARKDOWN
        )
        print("‚úÖ –ü–æ—Å—Ç –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω –±–µ–∑ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.")
        return

    keyboard = [
        [InlineKeyboardButton("‚úÖ –û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å", callback_data="approve")],
        [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å", callback_data="reject")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    msg = bot.send_message(
        chat_id=CHAT_ID,
        text=f"üìù –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã–π –ø–æ—Å—Ç –ø–æ —Ç–µ–º–µ *{current_topic}*:\n\n{message}",
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=reply_markup
    )
    pending_posts[msg.message_id] = message
    threading.Timer(600, lambda: auto_post(msg.message_id)).start()

def auto_post(message_id):
    if message_id not in pending_posts:
        return
    text = pending_posts.pop(message_id)
    bot.send_message(chat_id=CHAT_ID, text=f"‚è∞ –í—Ä–µ–º—è –≤—ã—à–ª–æ ‚Äî –ø–æ—Å—Ç –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏!\n\n{text}")

# === –ö–æ–º–∞–Ω–¥—ã –∞–≤—Ç–æ–ø–æ—Å—Ç–µ—Ä–∞ ===
def start(update, context):
    global autoposting_enabled
    autoposting_enabled = True
    update.message.reply_text("‚úÖ Autoposter –∑–∞–ø—É—â–µ–Ω!")

def stop(update, context):
    global autoposting_enabled
    autoposting_enabled = False
    update.message.reply_text("‚õî Autoposter –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!")

def status(update, context):
    status_text = "üü¢ –†–∞–±–æ—Ç–∞–µ—Ç" if autoposting_enabled else "üî¥ –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω"
    confirm_text = "üîî –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –í–ö–õ–Æ–ß–ï–ù–û" if require_confirmation else "‚öôÔ∏è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –í–´–ö–õ–Æ–ß–ï–ù–û"
    update.message.reply_text(
        f"üìä –°—Ç–∞—Ç—É—Å: {status_text}\n"
        f"{confirm_text}\n"
        f"–¢–µ–º–∞: {current_topic}\n"
        f"–ò–Ω—Ç–µ—Ä–≤–∞–ª: {post_interval} –º–∏–Ω\n"
        f"–ê–∫—Ç–∏–≤–Ω–æ–µ –≤—Ä–µ–º—è: {START_HOUR:02d}:00‚Äì{END_HOUR:02d}:00"
    )

def mode(update, context):
    global current_topic
    if not context.args:
        update.message.reply_text("–¢–µ–º—ã: –º–æ—Ç–∏–≤–∞—Ü–∏—è, —Ñ–∏–Ω–∞–Ω—Å—ã, –Ω–æ–≤–æ—Å—Ç–∏, —É–∫—Ä–∞–∏–Ω–∞, it.\n–ü—Ä–∏–º–µ—Ä: /mode —Ñ–∏–Ω–∞–Ω—Å—ã")
        return
    topic = context.args[0].lower()
    if topic in TOPICS:
        current_topic = topic
        update.message.reply_text(f"‚úÖ –¢–µ–º–∞ –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞: {topic}")
    else:
        update.message.reply_text("‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è —Ç–µ–º–∞.")

def interval(update, context):
    global post_interval
    if not context.args:
        update.message.reply_text("–ü—Ä–∏–º–µ—Ä: /interval 30 (–≤ –º–∏–Ω—É—Ç–∞—Ö)")
        return
    try:
        minutes = int(context.args[0])
        post_interval = minutes
        schedule.clear()
        schedule.every(post_interval).minutes.do(job)
        update.message.reply_text(f"‚úÖ –ò–Ω—Ç–µ—Ä–≤–∞–ª –∏–∑–º–µ–Ω—ë–Ω: –∫–∞–∂–¥—ã–µ {minutes} –º–∏–Ω—É—Ç.")
    except ValueError:
        update.message.reply_text("‚ùå –£–∫–∞–∂–∏—Ç–µ —á–∏—Å–ª–æ, –Ω–∞–ø—Ä–∏–º–µ—Ä /interval 60")

def test(update, context):
    message = generate_message()
    if not message:
        update.message.reply_text("‚ö†Ô∏è –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–æ—Å—Ç–∞.")
        return

    if not require_confirmation:
        bot.send_message(chat_id=CHAT_ID, text=f"üß™ –¢–µ—Å—Ç–æ–≤—ã–π –ø–æ—Å—Ç:\n\n{message}", parse_mode=ParseMode.MARKDOWN)
        return

    keyboard = [
        [InlineKeyboardButton("‚úÖ –û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å", callback_data="approve")],
        [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å", callback_data="reject")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    msg = update.message.reply_text(
        f"üß™ *–¢–µ—Å—Ç–æ–≤—ã–π –ø–æ—Å—Ç –ø–æ —Ç–µ–º–µ* _{current_topic}_:\n\n{message}",
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=reply_markup
    )
    pending_posts[msg.message_id] = message

def confirm_cmd(update, context):
    global require_confirmation
    if not context.args:
        state = "–≤–∫–ª—é—á–µ–Ω–æ ‚úÖ" if require_confirmation else "–≤—ã–∫–ª—é—á–µ–Ω–æ ‚ùå"
        update.message.reply_text(f"–¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è: {state}\n–ò—Å–ø–æ–ª—å–∑—É–π /confirm on –∏–ª–∏ /confirm off.")
        return
    arg = context.args[0].lower()
    if arg == "off":
        require_confirmation = False
        update.message.reply_text("‚öôÔ∏è –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø–æ—Å—Ç–æ–≤ –≤—ã–∫–ª—é—á–µ–Ω–æ.")
    elif arg == "on":
        require_confirmation = True
        update.message.reply_text("üîî –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø–æ—Å—Ç–æ–≤ –≤–∫–ª—é—á–µ–Ω–æ.")
    else:
        update.message.reply_text("‚ùå –ò—Å–ø–æ–ª—å–∑—É–π /confirm on –∏–ª–∏ /confirm off.")

def balance(update, context):
    update.message.reply_text("üí≥ –ë–∞–ª–∞–Ω—Å OpenAI –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ —á–µ—Ä–µ–∑ —Å—Ç–∞—Ä—ã–π API. –ë—É–¥–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω–æ –ø–æ–∑–∂–µ.")

# === –î–æ–ø. –∫–Ω–æ–ø–∫–∏ ===
def button(update, context):
    query = update.callback_query
    message_id = query.message.message_id
    if message_id not in pending_posts:
        query.answer("‚è≥ –≠—Ç–æ—Ç –ø–æ—Å—Ç —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω.")
        return
    if query.data == "approve":
        text = pending_posts.pop(message_id)
        bot.send_message(chat_id=CHAT_ID, text=f"‚úÖ –ü—É–±–ª–∏–∫—É—é –ø–æ—Å—Ç:\n\n{text}")
        query.edit_message_text("‚úÖ –ü–æ—Å—Ç –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω!")
    elif query.data == "reject":
        pending_posts.pop(message_id, None)
        bot.send_message(chat_id=CHAT_ID, text="üö´ –ü–æ—Å—Ç –æ—Ç–∫–ª–æ–Ω—ë–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º.")
        query.edit_message_text("‚ùå –ü–æ—Å—Ç –æ—Ç–º–µ–Ω—ë–Ω.")

# === –ö–æ–º–∞–Ω–¥—ã ThinClient v2 (–¥–∏–∞–ª–æ–≥ –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ) ===
def ask(update, context):
    if not context.args:
        update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /ask –≤–æ–ø—Ä–æ—Å –∫ GPT")
        return
    prompt = " ".join(context.args)
    update.message.reply_text("üß† –î—É–º–∞—é‚Ä¶")
    answer = gpt_reply(prompt)
    update.message.reply_text(answer[:4000])

def health(update, context):
    # —Å—Ç–∞—Ç—É—Å—ã systemd
    lines = []
    for svc in ["autoposter.service", "vm_api.service", "thinclient.service"]:
        code, out = systemctl(["is-active", svc])
        state = out.strip()
        emoji = "üü¢" if state == "active" and code == 0 else "üî¥"
        lines.append(f"{emoji} {svc} ‚Äî {state}")
    # uptime —á–µ—Ä–µ–∑ VM API
    try:
        r = requests.get(f"{VM_API}/uptime", timeout=5)
        if r.status_code == 200:
            up = r.json().get("output", "").strip()
            lines.append(f"‚úÖ VM API: {up}")
        else:
            lines.append(f"‚ö†Ô∏è VM API HTTP {r.status_code}")
    except Exception as e:
        lines.append(f"‚ùå VM API –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: {e}")
    update.message.reply_text("üìä Healthcheck:\n" + "\n".join(lines))

def restart_service(update, context):
    if not context.args:
        update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /restart autoposter|vm_api|thinclient")
        return
    name = context.args[0].strip().lower()
    svc_map = {
        "autoposter": "autoposter.service",
        "vm_api": "vm_api.service",
        "thinclient": "thinclient.service",
    }
    svc = svc_map.get(name)
    if not svc:
        update.message.reply_text("‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å–µ—Ä–≤–∏—Å. –î–æ—Å—Ç—É–ø–Ω–æ: autoposter, vm_api, thinclient")
        return
    code, out = systemctl(["restart", svc])
    if code == 0:
        update.message.reply_text(f"‚öôÔ∏è –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏–ª {svc} ‚úÖ")
    else:
        update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞ {svc}:\n{out[:1500]}")

def reboot_confirm(update, context):
    keyboard = [[
        InlineKeyboardButton("üîÑ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫—É", callback_data="reboot_yes"),
        InlineKeyboardButton("–û—Ç–º–µ–Ω–∞", callback_data="reboot_no"),
    ]]
    update.message.reply_text("‚ö†Ô∏è –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å –≤—Å—é VM?", reply_markup=InlineKeyboardMarkup(keyboard))

def reboot_button(update, context):
    query = update.callback_query
    if query.data == "reboot_yes":
        query.edit_message_text("üîÑ –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞—é VM‚Ä¶")
        try:
            subprocess.Popen(["sudo", "reboot"])
        except Exception as e:
            bot.send_message(chat_id=CHAT_ID, text=f"‚ùå –û—à–∏–±–∫–∞ reboot: {e}")
    else:
        query.edit_message_text("–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.")

def logs(update, context):
    # –ü–æ–∫–∞–∂–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 20 —Å—Ç—Ä–æ–∫ –ª–æ–≥–æ–≤ thinclient + autoposter
    tlog = tail_file(os.path.join(LOG_DIR, "thinclient.log"), 20)
    alog = tail_file(os.path.join(LOG_DIR, "autoposter.log"), 20)
    txt = "üìÑ *–ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ thinclient.log:*\n```\n" + tlog + "\n```\n"
    txt += "üìÑ *–ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ autoposter.log:*\n```\n" + alog + "\n```"
    update.message.reply_text(txt[:4000], parse_mode=ParseMode.MARKDOWN)

def help_command(update, context):
    help_text = (
        "<b>üìò –ö–æ–º–∞–Ω–¥—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è:</b>\n\n"
        "‚Ä¢ /start ‚Äî –∑–∞–ø—É—Å—Ç–∏—Ç—å –∞–≤—Ç–æ–ø–æ—Å—Ç–∏–Ω–≥\n"
        "‚Ä¢ /stop ‚Äî –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∞–≤—Ç–æ–ø–æ—Å—Ç–∏–Ω–≥\n"
        "‚Ä¢ /status ‚Äî —Å—Ç–∞—Ç—É—Å –∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∞–≤—Ç–æ–ø–æ—Å—Ç–µ—Ä–∞\n"
        "‚Ä¢ /mode <—Ç–µ–º–∞> ‚Äî —Å–º–µ–Ω–∏—Ç—å —Ç–µ–º—É –ø–æ—Å—Ç–æ–≤\n"
        "‚Ä¢ /interval <–º–∏–Ω—É—Ç—ã> ‚Äî –∑–∞–¥–∞—Ç—å –∏–Ω—Ç–µ—Ä–≤–∞–ª\n"
        "‚Ä¢ /test ‚Äî —Ç–µ—Å—Ç–æ–≤—ã–π –ø–æ—Å—Ç\n"
        "‚Ä¢ /confirm on|off ‚Äî –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ\n"
        "‚Ä¢ /ask <–≤–æ–ø—Ä–æ—Å> ‚Äî —Å–ø—Ä–æ—Å–∏—Ç—å GPT\n"
        "‚Ä¢ /health ‚Äî —Å–≤–æ–¥–∫–∞ —Å–µ—Ä–≤–∏—Å–æ–≤ –∏ –∞–ø—Ç–∞–π–º\n"
        "‚Ä¢ /restart <autoposter|vm_api|thinclient> ‚Äî —Ä–µ—Å—Ç–∞—Ä—Ç —Å–µ—Ä–≤–∏—Å–∞\n"
        "‚Ä¢ /reboot ‚Äî –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞ VM (—Å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ–º)\n"
        "‚Ä¢ /logs ‚Äî –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ –ª–æ–≥–æ–≤\n"
        "‚Ä¢ /help ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ –º–µ–Ω—é –ø–æ–º–æ—â–∏\n"
    )
    update.message.reply_text(help_text, parse_mode=ParseMode.HTML)

# === Telegram Bot ===
def run_bot():
    global bot
    bot = telegram.Bot(token=TELEGRAM_BOT_TOKEN)
    updater = Updater(TELEGRAM_BOT_TOKEN, use_context=True)
    dp = updater.dispatcher

    # –ê–≤—Ç–æ–ø–æ—Å—Ç–µ—Ä
    dp.add_handler(CommandHandler("start", start))
    dp.add_handler(CommandHandler("stop", stop))
    dp.add_handler(CommandHandler("status", status))
    dp.add_handler(CommandHandler("mode", mode))
    dp.add_handler(CommandHandler("interval", interval))
    dp.add_handler(CommandHandler("test", test))
    dp.add_handler(CommandHandler("confirm", confirm_cmd))
    dp.add_handler(CommandHandler("balance", balance))

    # ThinClient v2
    dp.add_handler(CommandHandler("ask", ask))
    dp.add_handler(CommandHandler("health", health))
    dp.add_handler(CommandHandler("restart", restart_service))
    dp.add_handler(CommandHandler("reboot", reboot_confirm))
    dp.add_handler(CommandHandler("logs", logs))
    dp.add_handler(CommandHandler("help", help_command))

    dp.add_handler(CallbackQueryHandler(button, pattern="^(approve|reject)$"))
    dp.add_handler(CallbackQueryHandler(reboot_button, pattern="^reboot_(yes|no)$"))

    updater.start_polling()
    print("ü§ñ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –∏ –∂–¥—ë—Ç –∫–æ–º–∞–Ω–¥—ã...")
    updater.idle()

def scheduler_thread():
    schedule.every(post_interval).minutes.do(job)
    while True:
        schedule.run_pending()
        time.sleep(10)

if __name__ == "__main__":
    internet_ok = check_internet()
    internet_status = "‚úÖ –ò–Ω—Ç–µ—Ä–Ω–µ—Ç –¥–æ—Å—Ç—É–ø–µ–Ω" if internet_ok else "‚ö†Ô∏è –ò–Ω—Ç–µ—Ä–Ω–µ—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω"
    threading.Thread(target=scheduler_thread, daemon=True).start()
    now_kyiv = datetime.now(TZ).strftime("%d.%m.%Y %H:%M")
    startup_text = (
        f"ü§ñ *Autoposter/Assistant –∑–∞–ø—É—â–µ–Ω!* üü¢\n"
        f"{internet_status}\n"
        f"üìÖ {now_kyiv} (–ø–æ –ö–∏–µ–≤—É)\n"
        f"üïí –ê–∫—Ç–∏–≤–Ω–æ–µ –≤—Ä–µ–º—è: {START_HOUR:02d}:00‚Äì{END_HOUR:02d}:00\n"
        f"‚è± –ò–Ω—Ç–µ—Ä–≤–∞–ª: –∫–∞–∂–¥—ã–µ {post_interval} –º–∏–Ω—É—Ç\n"
        f"üéØ –¢–µ–∫—É—â–∞—è —Ç–µ–º–∞: {current_topic}\n"
        f"üë®‚Äçüíª –†–∞–±–æ—Ç–∞: Oleg\n"
        "–ö–æ–º–∞–Ω–¥—ã: /help"
    )
    bot = telegram.Bot(token=TELEGRAM_BOT_TOKEN)
    bot.send_message(chat_id=CHAT_ID, text=startup_text, parse_mode=ParseMode.MARKDOWN)
    run_bot()
#!/usr/bin/env python3
import os
import time
import threading
import schedule
import subprocess
import requests
import openai
from datetime import datetime
import pytz
import socket
from dotenv import load_dotenv
import telegram
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, ParseMode
from telegram.ext import Updater, CommandHandler, CallbackQueryHandler, MessageHandler, Filters

# === –ó–∞–≥—Ä—É–∑–∫–∞ .env ===
load_dotenv()
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_TOKEN_POSTER")
CHAT_ID = os.getenv("CHAT_ID", "1359259211")  # –º–æ–∂–Ω–æ –≤—ã–Ω–µ—Å—Ç–∏ –≤ .env –ø—Ä–∏ –∂–µ–ª–∞–Ω–∏–∏

openai.api_key = OPENAI_API_KEY

# === –ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å –£–∫—Ä–∞–∏–Ω—ã ===
TZ = pytz.timezone("Europe/Kiev")

# === –†–∞–±–æ—á–µ–µ –≤—Ä–µ–º—è ===
START_HOUR = 1
END_HOUR = 23

# === –ê–≤—Ç–æ–ø–æ—Å—Ç–µ—Ä –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ ===
autoposting_enabled = True
require_confirmation = True
current_topic = "–º–æ—Ç–∏–≤–∞—Ü–∏—è"
pending_posts = {}
post_interval = 60  # –º–∏–Ω—É—Ç

TOPICS = {
    "–º–æ—Ç–∏–≤–∞—Ü–∏—è": "–ù–∞–ø–∏—à–∏ –≤–¥–æ—Ö–Ω–æ–≤–ª—è—é—â–∏–π –ø–æ—Å—Ç –¥–ª—è Telegram.",
    "—Ñ–∏–Ω–∞–Ω—Å—ã": "–°–æ–∑–¥–∞–π –∫–æ—Ä–æ—Ç–∫–∏–π –ø–æ—Å—Ç —Å —Å–æ–≤–µ—Ç–æ–º –ø–æ –ª–∏—á–Ω—ã–º —Ñ–∏–Ω–∞–Ω—Å–∞–º.",
    "–Ω–æ–≤–æ—Å—Ç–∏": "–°–æ–∑–¥–∞–π –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω—ã–π –ø–æ—Å—Ç —Å –ø–æ—Å–ª–µ–¥–Ω–∏–º–∏ –º–∏—Ä–æ–≤—ã–º–∏ –Ω–æ–≤–æ—Å—Ç—è–º–∏.",
    "—É–∫—Ä–∞–∏–Ω–∞": "–°–æ–∑–¥–∞–π –ø–æ—Å—Ç –æ –Ω–æ–≤–æ—Å—Ç—è—Ö –£–∫—Ä–∞–∏–Ω—ã.",
    "it": "–°–æ–∑–¥–∞–π –∫–æ—Ä–æ—Ç–∫–∏–π –ø–æ—Å—Ç –æ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—è—Ö –∏–ª–∏ –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω–æ–º –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç–µ."
}

LOG_DIR = "/home/Deltacom/autoposter"
VM_API = "http://127.0.0.1:5000/api/vm"
ALLOWED_SERVICES = {"autoposter.service", "vm_api.service", "thinclient.service"}

# === –£—Ç–∏–ª–∏—Ç—ã ===
def check_internet(host="8.8.8.8", port=53, timeout=3):
    try:
        socket.setdefaulttimeout(timeout)
        socket.socket(socket.AF_INET, socket.SOCK_STREAM).connect((host, port))
        return True
    except Exception:
        return False

def tail_file(path, lines=20):
    try:
        with open(path, "r", encoding="utf-8", errors="ignore") as f:
            data = f.readlines()[-lines:]
        text = "".join(data)
        # –û–≥—Ä–∞–Ω–∏—á–∏–º —Ä–∞–∑–º–µ—Ä –ø–æ–¥ Telegram (4096 —Å–∏–º–≤–æ–ª–æ–≤)
        return text[-3500:] if len(text) > 3500 else text
    except Exception as e:
        return f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å {path}: {e}"

def systemctl(cmd_list):
    try:
        out = subprocess.check_output(["systemctl"] + cmd_list, stderr=subprocess.STDOUT).decode("utf-8")
        return 0, out
    except subprocess.CalledProcessError as e:
        return e.returncode, e.output.decode("utf-8", errors="ignore")

# === GPT ===
def gpt_reply(prompt: str) -> str:
    try:
        resp = openai.ChatCompletion.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}]
        )
        return resp.choices[0].message["content"].strip()
    except Exception as e:
        return f"‚ö†Ô∏è –û—à–∏–±–∫–∞ GPT: {e}"

# === –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–æ—Å—Ç–∞ ===
def generate_message():
    prompt = TOPICS.get(current_topic, TOPICS["–º–æ—Ç–∏–≤–∞—Ü–∏—è"])
    try:
        resp = openai.ChatCompletion.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}]
        )
        return resp.choices[0].message["content"]
    except Exception as e:
        print(f"[–û—à–∏–±–∫–∞ GPT] {e}")
        return None

# === –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ —Å—É—Ç–æ–∫ ===
def within_active_hours():
    now = datetime.now(TZ)
    return START_HOUR <= now.hour < END_HOUR

# === –ê–≤—Ç–æ–ø–æ—Å—Ç–∏–Ω–≥ ===
def job():
    if not autoposting_enabled or not within_active_hours():
        return

    message = generate_message()
    if not message:
        return

    if not require_confirmation:
        bot.send_message(
            chat_id=CHAT_ID,
            text=f"üìù –ü–æ—Å—Ç –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ (—Ä–µ–∂–∏–º –±–µ–∑ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è):\n\n{message}",
            parse_mode=ParseMode.MARKDOWN
        )
        print("‚úÖ –ü–æ—Å—Ç –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω –±–µ–∑ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.")
        return

    keyboard = [
        [InlineKeyboardButton("‚úÖ –û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å", callback_data="approve")],
        [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å", callback_data="reject")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    msg = bot.send_message(
        chat_id=CHAT_ID,
        text=f"üìù –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã–π –ø–æ—Å—Ç –ø–æ —Ç–µ–º–µ *{current_topic}*:\n\n{message}",
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=reply_markup
    )
    pending_posts[msg.message_id] = message
    threading.Timer(600, lambda: auto_post(msg.message_id)).start()

def auto_post(message_id):
    if message_id not in pending_posts:
        return
    text = pending_posts.pop(message_id)
    bot.send_message(chat_id=CHAT_ID, text=f"‚è∞ –í—Ä–µ–º—è –≤—ã—à–ª–æ ‚Äî –ø–æ—Å—Ç –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏!\n\n{text}")

# === –ö–æ–º–∞–Ω–¥—ã –∞–≤—Ç–æ–ø–æ—Å—Ç–µ—Ä–∞ ===
def start(update, context):
    global autoposting_enabled
    autoposting_enabled = True
    update.message.reply_text("‚úÖ Autoposter –∑–∞–ø—É—â–µ–Ω!")

def stop(update, context):
    global autoposting_enabled
    autoposting_enabled = False
    update.message.reply_text("‚õî Autoposter –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!")

def status(update, context):
    status_text = "üü¢ –†–∞–±–æ—Ç–∞–µ—Ç" if autoposting_enabled else "üî¥ –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω"
    confirm_text = "üîî –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –í–ö–õ–Æ–ß–ï–ù–û" if require_confirmation else "‚öôÔ∏è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –í–´–ö–õ–Æ–ß–ï–ù–û"
    update.message.reply_text(
        f"üìä –°—Ç–∞—Ç—É—Å: {status_text}\n"
        f"{confirm_text}\n"
        f"–¢–µ–º–∞: {current_topic}\n"
        f"–ò–Ω—Ç–µ—Ä–≤–∞–ª: {post_interval} –º–∏–Ω\n"
        f"–ê–∫—Ç–∏–≤–Ω–æ–µ –≤—Ä–µ–º—è: {START_HOUR:02d}:00‚Äì{END_HOUR:02d}:00"
    )

def mode(update, context):
    global current_topic
    if not context.args:
        update.message.reply_text("–¢–µ–º—ã: –º–æ—Ç–∏–≤–∞—Ü–∏—è, —Ñ–∏–Ω–∞–Ω—Å—ã, –Ω–æ–≤–æ—Å—Ç–∏, —É–∫—Ä–∞–∏–Ω–∞, it.\n–ü—Ä–∏–º–µ—Ä: /mode —Ñ–∏–Ω–∞–Ω—Å—ã")
        return
    topic = context.args[0].lower()
    if topic in TOPICS:
        current_topic = topic
        update.message.reply_text(f"‚úÖ –¢–µ–º–∞ –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞: {topic}")
    else:
        update.message.reply_text("‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è —Ç–µ–º–∞.")

def interval(update, context):
    global post_interval
    if not context.args:
        update.message.reply_text("–ü—Ä–∏–º–µ—Ä: /interval 30 (–≤ –º–∏–Ω—É—Ç–∞—Ö)")
        return
    try:
        minutes = int(context.args[0])
        post_interval = minutes
        schedule.clear()
        schedule.every(post_interval).minutes.do(job)
        update.message.reply_text(f"‚úÖ –ò–Ω—Ç–µ—Ä–≤–∞–ª –∏–∑–º–µ–Ω—ë–Ω: –∫–∞–∂–¥—ã–µ {minutes} –º–∏–Ω—É—Ç.")
    except ValueError:
        update.message.reply_text("‚ùå –£–∫–∞–∂–∏—Ç–µ —á–∏—Å–ª–æ, –Ω–∞–ø—Ä–∏–º–µ—Ä /interval 60")

def test(update, context):
    message = generate_message()
    if not message:
        update.message.reply_text("‚ö†Ô∏è –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–æ—Å—Ç–∞.")
        return

    if not require_confirmation:
        bot.send_message(chat_id=CHAT_ID, text=f"üß™ –¢–µ—Å—Ç–æ–≤—ã–π –ø–æ—Å—Ç:\n\n{message}", parse_mode=ParseMode.MARKDOWN)
        return

    keyboard = [
        [InlineKeyboardButton("‚úÖ –û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å", callback_data="approve")],
        [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å", callback_data="reject")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    msg = update.message.reply_text(
        f"üß™ *–¢–µ—Å—Ç–æ–≤—ã–π –ø–æ—Å—Ç –ø–æ —Ç–µ–º–µ* _{current_topic}_:\n\n{message}",
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=reply_markup
    )
    pending_posts[msg.message_id] = message

def confirm_cmd(update, context):
    global require_confirmation
    if not context.args:
        state = "–≤–∫–ª—é—á–µ–Ω–æ ‚úÖ" if require_confirmation else "–≤—ã–∫–ª—é—á–µ–Ω–æ ‚ùå"
        update.message.reply_text(f"–¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è: {state}\n–ò—Å–ø–æ–ª—å–∑—É–π /confirm on –∏–ª–∏ /confirm off.")
        return
    arg = context.args[0].lower()
    if arg == "off":
        require_confirmation = False
        update.message.reply_text("‚öôÔ∏è –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø–æ—Å—Ç–æ–≤ –≤—ã–∫–ª—é—á–µ–Ω–æ.")
    elif arg == "on":
        require_confirmation = True
        update.message.reply_text("üîî –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø–æ—Å—Ç–æ–≤ –≤–∫–ª—é—á–µ–Ω–æ.")
    else:
        update.message.reply_text("‚ùå –ò—Å–ø–æ–ª—å–∑—É–π /confirm on –∏–ª–∏ /confirm off.")

def balance(update, context):
    update.message.reply_text("üí≥ –ë–∞–ª–∞–Ω—Å OpenAI –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ —á–µ—Ä–µ–∑ —Å—Ç–∞—Ä—ã–π API. –ë—É–¥–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω–æ –ø–æ–∑–∂–µ.")

# === –î–æ–ø. –∫–Ω–æ–ø–∫–∏ ===
def button(update, context):
    query = update.callback_query
    message_id = query.message.message_id
    if message_id not in pending_posts:
        query.answer("‚è≥ –≠—Ç–æ—Ç –ø–æ—Å—Ç —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω.")
        return
    if query.data == "approve":
        text = pending_posts.pop(message_id)
        bot.send_message(chat_id=CHAT_ID, text=f"‚úÖ –ü—É–±–ª–∏–∫—É—é –ø–æ—Å—Ç:\n\n{text}")
        query.edit_message_text("‚úÖ –ü–æ—Å—Ç –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω!")
    elif query.data == "reject":
        pending_posts.pop(message_id, None)
        bot.send_message(chat_id=CHAT_ID, text="üö´ –ü–æ—Å—Ç –æ—Ç–∫–ª–æ–Ω—ë–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º.")
        query.edit_message_text("‚ùå –ü–æ—Å—Ç –æ—Ç–º–µ–Ω—ë–Ω.")

# === –ö–æ–º–∞–Ω–¥—ã ThinClient v2 (–¥–∏–∞–ª–æ–≥ –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ) ===
def ask(update, context):
    if not context.args:
        update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /ask –≤–æ–ø—Ä–æ—Å –∫ GPT")
        return
    prompt = " ".join(context.args)
    update.message.reply_text("üß† –î—É–º–∞—é‚Ä¶")
    answer = gpt_reply(prompt)
    update.message.reply_text(answer[:4000])

def health(update, context):
    # —Å—Ç–∞—Ç—É—Å—ã systemd
    lines = []
    for svc in ["autoposter.service", "vm_api.service", "thinclient.service"]:
        code, out = systemctl(["is-active", svc])
        state = out.strip()
        emoji = "üü¢" if state == "active" and code == 0 else "üî¥"
        lines.append(f"{emoji} {svc} ‚Äî {state}")
    # uptime —á–µ—Ä–µ–∑ VM API
    try:
        r = requests.get(f"{VM_API}/uptime", timeout=5)
        if r.status_code == 200:
            up = r.json().get("output", "").strip()
            lines.append(f"‚úÖ VM API: {up}")
        else:
            lines.append(f"‚ö†Ô∏è VM API HTTP {r.status_code}")
    except Exception as e:
        lines.append(f"‚ùå VM API –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: {e}")
    update.message.reply_text("üìä Healthcheck:\n" + "\n".join(lines))

def restart_service(update, context):
    if not context.args:
        update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /restart autoposter|vm_api|thinclient")
        return
    name = context.args[0].strip().lower()
    svc_map = {
        "autoposter": "autoposter.service",
        "vm_api": "vm_api.service",
        "thinclient": "thinclient.service",
    }
    svc = svc_map.get(name)
    if not svc:
        update.message.reply_text("‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å–µ—Ä–≤–∏—Å. –î–æ—Å—Ç—É–ø–Ω–æ: autoposter, vm_api, thinclient")
        return
    code, out = systemctl(["restart", svc])
    if code == 0:
        update.message.reply_text(f"‚öôÔ∏è –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏–ª {svc} ‚úÖ")
    else:
        update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞ {svc}:\n{out[:1500]}")

def reboot_confirm(update, context):
    keyboard = [[
        InlineKeyboardButton("üîÑ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫—É", callback_data="reboot_yes"),
        InlineKeyboardButton("–û—Ç–º–µ–Ω–∞", callback_data="reboot_no"),
    ]]
    update.message.reply_text("‚ö†Ô∏è –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å –≤—Å—é VM?", reply_markup=InlineKeyboardMarkup(keyboard))

def reboot_button(update, context):
    query = update.callback_query
    if query.data == "reboot_yes":
        query.edit_message_text("üîÑ –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞—é VM‚Ä¶")
        try:
            subprocess.Popen(["sudo", "reboot"])
        except Exception as e:
            bot.send_message(chat_id=CHAT_ID, text=f"‚ùå –û—à–∏–±–∫–∞ reboot: {e}")
    else:
        query.edit_message_text("–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.")

def logs(update, context):
    # –ü–æ–∫–∞–∂–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 20 —Å—Ç—Ä–æ–∫ –ª–æ–≥–æ–≤ thinclient + autoposter
    tlog = tail_file(os.path.join(LOG_DIR, "thinclient.log"), 20)
    alog = tail_file(os.path.join(LOG_DIR, "autoposter.log"), 20)
    txt = "üìÑ *–ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ thinclient.log:*\n```\n" + tlog + "\n```\n"
    txt += "üìÑ *–ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ autoposter.log:*\n```\n" + alog + "\n```"
    update.message.reply_text(txt[:4000], parse_mode=ParseMode.MARKDOWN)

def help_command(update, context):
    help_text = (
        "<b>üìò –ö–æ–º–∞–Ω–¥—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è:</b>\n\n"
        "‚Ä¢ /start ‚Äî –∑–∞–ø—É—Å—Ç–∏—Ç—å –∞–≤—Ç–æ–ø–æ—Å—Ç–∏–Ω–≥\n"
        "‚Ä¢ /stop ‚Äî –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∞–≤—Ç–æ–ø–æ—Å—Ç–∏–Ω–≥\n"
        "‚Ä¢ /status ‚Äî —Å—Ç–∞—Ç—É—Å –∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∞–≤—Ç–æ–ø–æ—Å—Ç–µ—Ä–∞\n"
        "‚Ä¢ /mode <—Ç–µ–º–∞> ‚Äî —Å–º–µ–Ω–∏—Ç—å —Ç–µ–º—É –ø–æ—Å—Ç–æ–≤\n"
        "‚Ä¢ /interval <–º–∏–Ω—É—Ç—ã> ‚Äî –∑–∞–¥–∞—Ç—å –∏–Ω—Ç–µ—Ä–≤–∞–ª\n"
        "‚Ä¢ /test ‚Äî —Ç–µ—Å—Ç–æ–≤—ã–π –ø–æ—Å—Ç\n"
        "‚Ä¢ /confirm on|off ‚Äî –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ\n"
        "‚Ä¢ /ask <–≤–æ–ø—Ä–æ—Å> ‚Äî —Å–ø—Ä–æ—Å–∏—Ç—å GPT\n"
        "‚Ä¢ /health ‚Äî —Å–≤–æ–¥–∫–∞ —Å–µ—Ä–≤–∏—Å–æ–≤ –∏ –∞–ø—Ç–∞–π–º\n"
        "‚Ä¢ /restart <autoposter|vm_api|thinclient> ‚Äî —Ä–µ—Å—Ç–∞—Ä—Ç —Å–µ—Ä–≤–∏—Å–∞\n"
        "‚Ä¢ /reboot ‚Äî –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞ VM (—Å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ–º)\n"
        "‚Ä¢ /logs ‚Äî –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ –ª–æ–≥–æ–≤\n"
        "‚Ä¢ /help ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ –º–µ–Ω—é –ø–æ–º–æ—â–∏\n"
    )
    update.message.reply_text(help_text, parse_mode=ParseMode.HTML)

# === Telegram Bot ===
def run_bot():
    global bot
    bot = telegram.Bot(token=TELEGRAM_BOT_TOKEN)
    updater = Updater(TELEGRAM_BOT_TOKEN, use_context=True)
    dp = updater.dispatcher

    # –ê–≤—Ç–æ–ø–æ—Å—Ç–µ—Ä
    dp.add_handler(CommandHandler("start", start))
    dp.add_handler(CommandHandler("stop", stop))
    dp.add_handler(CommandHandler("status", status))
    dp.add_handler(CommandHandler("mode", mode))
    dp.add_handler(CommandHandler("interval", interval))
    dp.add_handler(CommandHandler("test", test))
    dp.add_handler(CommandHandler("confirm", confirm_cmd))
    dp.add_handler(CommandHandler("balance", balance))

    # ThinClient v2
    dp.add_handler(CommandHandler("ask", ask))
    dp.add_handler(CommandHandler("health", health))
    dp.add_handler(CommandHandler("restart", restart_service))
    dp.add_handler(CommandHandler("reboot", reboot_confirm))
    dp.add_handler(CommandHandler("logs", logs))
    dp.add_handler(CommandHandler("help", help_command))

    dp.add_handler(CallbackQueryHandler(button, pattern="^(approve|reject)$"))
    dp.add_handler(CallbackQueryHandler(reboot_button, pattern="^reboot_(yes|no)$"))

    updater.start_polling()
    print("ü§ñ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –∏ –∂–¥—ë—Ç –∫–æ–º–∞–Ω–¥—ã...")
    updater.idle()

def scheduler_thread():
    schedule.every(post_interval).minutes.do(job)
    while True:
        schedule.run_pending()
        time.sleep(10)

if __name__ == "__main__":
    internet_ok = check_internet()
    internet_status = "‚úÖ –ò–Ω—Ç–µ—Ä–Ω–µ—Ç –¥–æ—Å—Ç—É–ø–µ–Ω" if internet_ok else "‚ö†Ô∏è –ò–Ω—Ç–µ—Ä–Ω–µ—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω"
    threading.Thread(target=scheduler_thread, daemon=True).start()
    now_kyiv = datetime.now(TZ).strftime("%d.%m.%Y %H:%M")
    startup_text = (
        f"ü§ñ *Autoposter/Assistant –∑–∞–ø—É—â–µ–Ω!* üü¢\n"
        f"{internet_status}\n"
        f"üìÖ {now_kyiv} (–ø–æ –ö–∏–µ–≤—É)\n"
        f"üïí –ê–∫—Ç–∏–≤–Ω–æ–µ –≤—Ä–µ–º—è: {START_HOUR:02d}:00‚Äì{END_HOUR:02d}:00\n"
        f"‚è± –ò–Ω—Ç–µ—Ä–≤–∞–ª: –∫–∞–∂–¥—ã–µ {post_interval} –º–∏–Ω—É—Ç\n"
        f"üéØ –¢–µ–∫—É—â–∞—è —Ç–µ–º–∞: {current_topic}\n"
        f"üë®‚Äçüíª –†–∞–±–æ—Ç–∞: Oleg\n"
        "–ö–æ–º–∞–Ω–¥—ã: /help"
    )
    bot = telegram.Bot(token=TELEGRAM_BOT_TOKEN)
    bot.send_message(chat_id=CHAT_ID, text=startup_text, parse_mode=ParseMode.MARKDOWN)
    run_bot()
